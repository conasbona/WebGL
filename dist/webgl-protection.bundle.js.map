{"version":3,"file":"webgl-protection.bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,6BAAQ;AACpC,eAAe,mBAAO,CAAC,iCAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,mEAA2B;AACxE,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,mEAA2B;AACxE,QAAQ,sBAAsB,EAAE,mBAAO,CAAC,yDAAsB;AAC9D,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,iEAA0B;AACtE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA,yCAAyC;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,EAAE,uBAAuB,GAAG,+BAA+B;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,aAAa;AAC5B;AACA;AACA,yBAAyB,UAAU,GAAG,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,0CAA0C,cAAc;AACxD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA,0CAA0C,2BAA2B,aAAa,wBAAwB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,GAAG,MAAM;AACtD,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,cAAc,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAoD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,aAAa,uBAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA,wBAAwB,WAAW,GAAG,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA,6BAA6B,EAAE,GAAG,EAAE,GAAG,oBAAoB;AAC3D;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM,GAAG,OAAO;AAC/D;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA,6BAA6B,EAAE,GAAG,EAAE,GAAG,oBAAoB;AAC3D;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCxSA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://webgl-fingerprint-protection/./src/browser-entry.js","webpack://webgl-fingerprint-protection/./src/config.js","webpack://webgl-fingerprint-protection/./src/prng.js","webpack://webgl-fingerprint-protection/./src/spoofing/drawSpoof.js","webpack://webgl-fingerprint-protection/./src/spoofing/extensionSpoof.js","webpack://webgl-fingerprint-protection/./src/spoofing/parameterSpoof.js","webpack://webgl-fingerprint-protection/./src/spoofing/readbackSpoof.js","webpack://webgl-fingerprint-protection/webpack/bootstrap","webpack://webgl-fingerprint-protection/webpack/before-startup","webpack://webgl-fingerprint-protection/webpack/startup","webpack://webgl-fingerprint-protection/webpack/after-startup"],"sourcesContent":["// src/browser-entry.js\r\n\r\n// Import required modules with browser-compatible alternatives\r\nconst SessionPRNG = require('./prng');\r\nconst Config = require('./config');\r\n\r\n// Global state\r\nlet initialized = false;\r\nlet config = null;\r\nlet prng = null;\r\nlet activeProfile = null;\r\nlet originalGetContext = null;\r\n\r\n// Mock ProfileManager that doesn't rely on fs\r\nconst ProfileManager = {\r\n  // Sample GPU profiles that don't require loading from disk\r\n  profiles: [\r\n    {\r\n      name: \"nvidia_rtx_3080\",\r\n      vendor: \"WebKit\",\r\n      renderer: \"WebKit WebGL\",\r\n      unmaskedVendor: \"Google Inc. (NVIDIA)\",\r\n      unmaskedRenderer: \"ANGLE (NVIDIA, NVIDIA GeForce RTX 3080 Direct3D11 vs_5_0 ps_5_0, D3D11)\",\r\n      version: \"WebGL 2.0 (OpenGL ES 3.0 Chromium)\",\r\n      version2: \"WebGL 2.0 (OpenGL ES 3.0 Chromium)\",\r\n      shadingLanguage: \"WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)\",\r\n      shadingLanguage2: \"WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)\",\r\n      gpuVendor: \"nvidia\",\r\n      gpuTier: \"high\",\r\n      supportsWebGL2: true,\r\n      parameters: {\r\n        MAX_TEXTURE_SIZE: 32768,\r\n        MAX_RENDERBUFFER_SIZE: 32768,\r\n        MAX_VIEWPORT_DIMS: [32768, 32768],\r\n        ALIASED_LINE_WIDTH_RANGE: [1, 1],\r\n        ALIASED_POINT_SIZE_RANGE: [1, 1024],\r\n        MAX_VERTEX_ATTRIBS: 16,\r\n        MAX_VERTEX_UNIFORM_VECTORS: 4096,\r\n        MAX_FRAGMENT_UNIFORM_VECTORS: 1024,\r\n        MAX_VARYING_VECTORS: 30,\r\n        MAX_VERTEX_TEXTURE_IMAGE_UNITS: 16,\r\n        MAX_TEXTURE_IMAGE_UNITS: 16,\r\n        RED_BITS: 8,\r\n        GREEN_BITS: 8,\r\n        BLUE_BITS: 8,\r\n        ALPHA_BITS: 8,\r\n        DEPTH_BITS: 24,\r\n        STENCIL_BITS: 0\r\n      },\r\n      webgl2Parameters: {\r\n        MAX_ELEMENT_INDEX: 4294967294,\r\n        MAX_UNIFORM_BLOCK_SIZE: 65536,\r\n        MAX_VERTEX_UNIFORM_BLOCKS: 16,\r\n        MAX_FRAGMENT_UNIFORM_BLOCKS: 16,\r\n        MAX_COMBINED_UNIFORM_BLOCKS: 32,\r\n        MAX_DRAW_BUFFERS: 8,\r\n        MAX_COLOR_ATTACHMENTS: 8,\r\n        MAX_SAMPLES: 16\r\n      },\r\n      // More realistic extension list with commonly available extensions\r\n      extensions: [\r\n        \"ANGLE_instanced_arrays\",\r\n        \"EXT_blend_minmax\",\r\n        \"EXT_color_buffer_half_float\",\r\n        \"EXT_float_blend\",\r\n        \"EXT_texture_filter_anisotropic\",\r\n        \"OES_element_index_uint\",\r\n        \"OES_standard_derivatives\",\r\n        \"OES_texture_float\",\r\n        \"OES_texture_float_linear\",\r\n        \"OES_texture_half_float\",\r\n        \"OES_texture_half_float_linear\",\r\n        \"OES_vertex_array_object\",\r\n        \"WEBGL_color_buffer_float\",\r\n        \"WEBGL_compressed_texture_s3tc\",\r\n        \"WEBGL_lose_context\"\r\n      ],\r\n      webgl2Extensions: [\r\n        \"EXT_color_buffer_float\",\r\n        \"EXT_texture_filter_anisotropic\",\r\n        \"OES_draw_buffers_indexed\",\r\n        \"WEBGL_compressed_texture_s3tc\",\r\n        \"WEBGL_compressed_texture_s3tc_srgb\",\r\n        \"WEBGL_debug_shaders\",\r\n        \"EXT_texture_norm16\",\r\n        \"EXT_texture_compression_bptc\",\r\n        \"KHR_parallel_shader_compile\"\r\n      ]\r\n    },\r\n    {\r\n      name: \"amd_radeon_rx_6800\",\r\n      vendor: \"WebKit\",\r\n      renderer: \"WebKit WebGL\",\r\n      unmaskedVendor: \"Google Inc. (AMD)\",\r\n      unmaskedRenderer: \"ANGLE (AMD, AMD Radeon RX 6800 XT Direct3D11 vs_5_0 ps_5_0, D3D11)\",\r\n      version: \"WebGL 2.0 (OpenGL ES 3.0 Chromium)\",\r\n      version2: \"WebGL 2.0 (OpenGL ES 3.0 Chromium)\",\r\n      shadingLanguage: \"WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)\",\r\n      shadingLanguage2: \"WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)\",\r\n      gpuVendor: \"amd\",\r\n      gpuTier: \"high\",\r\n      supportsWebGL2: true,\r\n      parameters: {\r\n        MAX_TEXTURE_SIZE: 16384,\r\n        MAX_RENDERBUFFER_SIZE: 16384,\r\n        MAX_VIEWPORT_DIMS: [16384, 16384],\r\n        ALIASED_LINE_WIDTH_RANGE: [1, 1],\r\n        ALIASED_POINT_SIZE_RANGE: [1, 1024],\r\n        MAX_VERTEX_ATTRIBS: 16,\r\n        MAX_VERTEX_UNIFORM_VECTORS: 4096,\r\n        MAX_FRAGMENT_UNIFORM_VECTORS: 1024,\r\n        MAX_VARYING_VECTORS: 30,\r\n        MAX_VERTEX_TEXTURE_IMAGE_UNITS: 16,\r\n        MAX_TEXTURE_IMAGE_UNITS: 16,\r\n        RED_BITS: 8,\r\n        GREEN_BITS: 8,\r\n        BLUE_BITS: 8,\r\n        ALPHA_BITS: 8,\r\n        DEPTH_BITS: 24,\r\n        STENCIL_BITS: 0\r\n      },\r\n      webgl2Parameters: {\r\n        MAX_ELEMENT_INDEX: 4294967294,\r\n        MAX_UNIFORM_BLOCK_SIZE: 65536,\r\n        MAX_VERTEX_UNIFORM_BLOCKS: 16,\r\n        MAX_FRAGMENT_UNIFORM_BLOCKS: 16,\r\n        MAX_COMBINED_UNIFORM_BLOCKS: 32,\r\n        MAX_DRAW_BUFFERS: 8,\r\n        MAX_COLOR_ATTACHMENTS: 8,\r\n        MAX_SAMPLES: 16\r\n      },\r\n      extensions: [\r\n        \"ANGLE_instanced_arrays\",\r\n        \"EXT_blend_minmax\",\r\n        \"EXT_color_buffer_half_float\",\r\n        \"EXT_float_blend\",\r\n        \"EXT_texture_filter_anisotropic\",\r\n        \"OES_element_index_uint\",\r\n        \"OES_standard_derivatives\",\r\n        \"OES_texture_float\",\r\n        \"OES_texture_float_linear\",\r\n        \"OES_texture_half_float\",\r\n        \"OES_texture_half_float_linear\",\r\n        \"OES_vertex_array_object\",\r\n        \"WEBGL_color_buffer_float\",\r\n        \"WEBGL_compressed_texture_s3tc\",\r\n        \"WEBGL_lose_context\"\r\n      ],\r\n      webgl2Extensions: [\r\n        \"EXT_color_buffer_float\",\r\n        \"EXT_texture_filter_anisotropic\",\r\n        \"OES_draw_buffers_indexed\",\r\n        \"WEBGL_compressed_texture_s3tc\",\r\n        \"WEBGL_compressed_texture_s3tc_srgb\",\r\n        \"WEBGL_debug_shaders\",\r\n        \"EXT_texture_norm16\",\r\n        \"EXT_texture_compression_rgtc\",\r\n        \"KHR_parallel_shader_compile\"\r\n      ]\r\n    }\r\n  ],\r\n\r\n  // Simplified selectProfile method\r\n  selectProfile: function(prng) {\r\n    // Select a random profile\r\n    const profileIndex = Math.floor(prng.random() * this.profiles.length);\r\n    return this.profiles[profileIndex];\r\n  }\r\n};\r\n\r\n// Import spoofing modules\r\nconst { installParameterSpoofing } = require('./spoofing/parameterSpoof');\r\nconst { installExtensionSpoofing } = require('./spoofing/extensionSpoof');\r\nconst { installDrawSpoofing } = require('./spoofing/drawSpoof');\r\nconst { installReadbackSpoofing } = require('./spoofing/readbackSpoof');\r\n\r\n/**\r\n * Initialize the WebGL fingerprinting protection\r\n * @param {Object} userConfig - User-provided configuration options\r\n * @returns {Promise<Object>} Configuration and API methods\r\n */\r\nasync function initialize(userConfig = {}) {\r\n  if (initialized) {\r\n    return { config, prng };\r\n  }\r\n\r\n  try {\r\n    // Log initialization start\r\n    console.log('[WebGL Protection] Initializing...');\r\n\r\n    // Create configuration with user options\r\n    config = new Config(userConfig);\r\n\r\n    // Initialize PRNG with optional seed\r\n    const seed = config.get('seed');\r\n    prng = new SessionPRNG(seed);\r\n\r\n    // Select a random profile\r\n    const preferredVendor = config.get('profile.preferredVendor');\r\n    const preferredTier = config.get('profile.preferredTier');\r\n    activeProfile = ProfileManager.selectProfile(prng);\r\n    \r\n    // Log profile selection\r\n    console.log(`[WebGL Protection] Selected profile: ${activeProfile.gpuVendor} ${activeProfile.gpuTier} (${activeProfile.unmaskedRenderer})`);\r\n\r\n    // Hook canvas getContext to intercept WebGL context creation\r\n    installContextHook();\r\n\r\n    // Mark as initialized\r\n    initialized = true;\r\n    console.log('[WebGL Protection] Successfully initialized');\r\n\r\n    return { config, prng };\r\n  } catch (error) {\r\n    console.error('[WebGL Protection] Initialization error:', error);\r\n    return { error: 'Failed to initialize WebGL fingerprinting protection' };\r\n  }\r\n}\r\n\r\n/**\r\n * Install hook for canvas.getContext to intercept WebGL context creation\r\n */\r\nfunction installContextHook() {\r\n  // Store original method\r\n  originalGetContext = HTMLCanvasElement.prototype.getContext;\r\n  \r\n  console.log('[WebGL Protection] Installing context hook');\r\n\r\n  // Replace with our version\r\n  HTMLCanvasElement.prototype.getContext = function(contextType, ...args) {\r\n    // Get original context\r\n    const context = originalGetContext.call(this, contextType, ...args);\r\n\r\n    // Skip if context creation failed or protection is disabled\r\n    if (!context || !config.get('enabled')) {\r\n      return context;\r\n    }\r\n\r\n    // Apply WebGL spoofing if this is a WebGL context\r\n    if (contextType === 'webgl' || contextType === 'experimental-webgl' || contextType === 'webgl2') {\r\n      console.log(`[WebGL Protection] Intercepted context creation: ${contextType}`);\r\n      \r\n      // Create shared state object for cross-module communication\r\n      const state = {\r\n        noiseApplied: false\r\n      };\r\n\r\n      // Apply spoofing modules\r\n      applyWebGLSpoofing(context, contextType, state);\r\n\r\n      // Visual indicator for debugging\r\n      if (config.get('debug.visualIndicator')) {\r\n        this.style.outline = '2px solid rgba(0, 128, 255, 0.5)';\r\n        this.setAttribute('data-webgl-protected', 'true');\r\n      }\r\n    }\r\n\r\n    return context;\r\n  };\r\n}\r\n\r\n/**\r\n * Apply WebGL fingerprinting protection to a context\r\n * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context\r\n * @param {string} contextType - The context type ('webgl', 'webgl2', etc.)\r\n * @param {Object} state - Shared state for cross-module communication\r\n */\r\n// In browser-entry.js - Update the applyWebGLSpoofing function\r\n\r\nfunction applyWebGLSpoofing(gl, contextType, state) {\r\n  // Determine if this is a WebGL2 context\r\n  const isWebGL2 = contextType === 'webgl2';\r\n\r\n  // Skip WebGL2 if profile doesn't support it\r\n  if (isWebGL2 && !activeProfile.supportsWebGL2) {\r\n    console.log('[WebGL Protection] Skipping WebGL2 spoofing (profile does not support WebGL2)');\r\n    return;\r\n  }\r\n\r\n  // Detect testing sites to enable compatibility mode\r\n  const isTestSite = typeof window !== 'undefined' && (\r\n    window.location.hostname.includes('browserleaks.com') ||\r\n    window.location.hostname.includes('amiunique.org') ||\r\n    window.location.hostname.includes('fingerprintjs.github.io')\r\n  );\r\n  \r\n  if (isTestSite) {\r\n    console.log('[WebGL Protection] Fingerprinting test site detected - using minimal protection mode');\r\n    \r\n    // Use extremely minimal protection for test sites\r\n    // Only block the WEBGL_debug_renderer_info extension\r\n    const originalGetExtension = gl.getExtension;\r\n    gl.getExtension = function(name) {\r\n      if (name === 'WEBGL_debug_renderer_info') {\r\n        console.log('[WebGL Protection] Blocking WEBGL_debug_renderer_info extension');\r\n        return null;\r\n      }\r\n      return originalGetExtension.call(this, name);\r\n    };\r\n    \r\n    // Only spoof the unmasked vendor and renderer\r\n    const originalGetParameter = gl.getParameter;\r\n    gl.getParameter = function(pname) {\r\n      // Constants for WEBGL_debug_renderer_info extension\r\n      const UNMASKED_VENDOR_WEBGL = 0x9245;\r\n      const UNMASKED_RENDERER_WEBGL = 0x9246;\r\n      \r\n      if (pname === UNMASKED_VENDOR_WEBGL) {\r\n        console.log('[WebGL Protection] Spoofing unmasked vendor');\r\n        return activeProfile.unmaskedVendor;\r\n      } \r\n      else if (pname === UNMASKED_RENDERER_WEBGL) {\r\n        console.log('[WebGL Protection] Spoofing unmasked renderer');\r\n        return activeProfile.unmaskedRenderer;\r\n      }\r\n      \r\n      // Leave all other parameters untouched\r\n      return originalGetParameter.call(this, pname);\r\n    };\r\n    \r\n    console.log('[WebGL Protection] Minimal protection applied for compatibility');\r\n    return;\r\n  }\r\n\r\n  // For non-test sites, apply full protection\r\n  \r\n  // Apply spoofing modules with appropriate settings\r\n  // Check config directly rather than using isEnabled\r\n  if (config.config.parameters && config.config.parameters.enabled) {\r\n    installParameterSpoofing(gl, activeProfile, prng, config);\r\n  }\r\n\r\n  if (config.config.extensions && config.config.extensions.enabled) {\r\n    installExtensionSpoofing(gl, activeProfile, prng, config);\r\n  }\r\n\r\n  if (config.config.drawCalls && config.config.drawCalls.enabled) {\r\n    installDrawSpoofing(gl, activeProfile, prng, config, state);\r\n  }\r\n\r\n  if (config.config.readback && config.config.readback.enabled) {\r\n    installReadbackSpoofing(gl, activeProfile, prng, config, state);\r\n  }\r\n}\r\n\r\n/**\r\n * Disable WebGL fingerprinting protection\r\n */\r\nfunction disable() {\r\n  if (!initialized) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // Restore original getContext method\r\n    if (originalGetContext) {\r\n      HTMLCanvasElement.prototype.getContext = originalGetContext;\r\n    }\r\n    \r\n    // Mark as uninitialized\r\n    initialized = false;\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('[WebGL Protection] Error disabling protection:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current status of the WebGL fingerprinting protection\r\n */\r\nfunction getStatus() {\r\n  return {\r\n    initialized,\r\n    enabled: initialized && config && config.get('enabled'),\r\n    profile: activeProfile ? {\r\n      vendor: activeProfile.gpuVendor,\r\n      tier: activeProfile.gpuTier,\r\n      webgl2Support: activeProfile.supportsWebGL2\r\n    } : null\r\n  };\r\n}\r\n\r\n// Export for browser environment\r\nif (typeof window !== 'undefined') {\r\n  // Add auto-initialization\r\n  window.enableWebGLProtection = async function(userConfig = {}) {\r\n    console.log('[WebGL Protection] Browser activation started');\r\n    return await initialize(userConfig || window._webglProtectionConfig || {});\r\n  };\r\n\r\n  // Auto-initialize if config is present\r\n  if (window._webglProtectionConfig) {\r\n    console.log('[WebGL Protection] Auto-initializing from config');\r\n    setTimeout(() => {\r\n      window.enableWebGLProtection(window._webglProtectionConfig)\r\n        .then(result => {\r\n          console.log('[WebGL Protection] Auto-initialization complete', result);\r\n        })\r\n        .catch(error => {\r\n          console.error('[WebGL Protection] Auto-initialization failed:', error);\r\n        });\r\n    }, 0);\r\n  }\r\n}\r\n\r\n// Add diagnostic function to window object\r\nif (typeof window !== 'undefined') {\r\n  window.diagnoseWebGL = function() {\r\n    console.log(\"=== WebGL Diagnostics ===\");\r\n    \r\n    try {\r\n      // Test basic context creation\r\n      const canvas = document.createElement('canvas');\r\n      console.log(\"Canvas created\");\r\n      \r\n      // Try to get WebGL1 context\r\n      const gl1 = canvas.getContext('webgl');\r\n      console.log(\"WebGL1 context creation result:\", !!gl1);\r\n      \r\n      if (gl1) {\r\n        // Check basic parameters\r\n        console.log(\"Vendor:\", gl1.getParameter(gl1.VENDOR));\r\n        console.log(\"Renderer:\", gl1.getParameter(gl1.RENDERER));\r\n        \r\n        // Try to get extensions\r\n        const extensions = gl1.getSupportedExtensions();\r\n        console.log(\"Extensions count:\", extensions ? extensions.length : 0);\r\n        console.log(\"Extensions:\", extensions);\r\n        \r\n        // Try a simple render test\r\n        gl1.clearColor(1.0, 0.0, 0.0, 1.0);\r\n        gl1.clear(gl1.COLOR_BUFFER_BIT);\r\n        console.log(\"Basic render test complete\");\r\n        \r\n        // Try readback\r\n        const pixels = new Uint8Array(4);\r\n        gl1.readPixels(0, 0, 1, 1, gl1.RGBA, gl1.UNSIGNED_BYTE, pixels);\r\n        console.log(\"Readback result:\", Array.from(pixels));\r\n      }\r\n      \r\n      // Try WebGL2\r\n      const gl2 = canvas.getContext('webgl2');\r\n      console.log(\"WebGL2 context creation result:\", !!gl2);\r\n      \r\n      return {\r\n        webgl1: !!gl1,\r\n        webgl2: !!gl2,\r\n        diagnosticsRun: true\r\n      };\r\n    } catch (e) {\r\n      console.error(\"WebGL Diagnostics error:\", e);\r\n      return {\r\n        error: e.message,\r\n        diagnosticsRun: true\r\n      };\r\n    }\r\n  };\r\n  \r\n  // Auto-run diagnostics after initialization\r\n  setTimeout(() => {\r\n    if (window.diagnoseWebGL) {\r\n      console.log(\"Running automatic WebGL diagnostics...\");\r\n      window.diagnoseWebGL();\r\n    }\r\n  }, 2000);\r\n}\r\n\r\n// Export API\r\nmodule.exports = {\r\n  initialize,\r\n  disable,\r\n  getStatus\r\n};","// src/config.js\r\n\r\n/**\r\n * Default configuration for WebGL fingerprinting protection\r\n */\r\nconst defaultConfig = {\r\n  /**\r\n   * Master switch to enable/disable the entire protection\r\n   */\r\n  enabled: true,\r\n\r\n  /**\r\n   * Profile selection settings\r\n   */\r\n  profile: {\r\n    /**\r\n     * Path to the webgl.json file (for Node.js environments)\r\n     * Set to null for browser environments\r\n     */\r\n    profilePath: null,\r\n    \r\n    /**\r\n     * Vendor preference (optional)\r\n     * If set, will try to select profiles matching this vendor\r\n     * Options: 'nvidia', 'amd', 'intel', null (random)\r\n     */\r\n    preferredVendor: null,\r\n    \r\n    /**\r\n     * GPU tier preference (optional)\r\n     * If set, will try to select profiles matching this tier\r\n     * Options: 'high', 'mid', 'low', null (random)\r\n     */\r\n    preferredTier: null\r\n  },\r\n\r\n  /**\r\n   * Parameter spoofing settings\r\n   */\r\n  parameters: {\r\n    /**\r\n     * Enable parameter spoofing\r\n     */\r\n    enabled: true,\r\n    \r\n    /**\r\n     * Percentage to jitter numeric parameters (0.0 to 1.0)\r\n     * 0.03 means values can vary by ±3%\r\n     */\r\n    jitterPercent: 0.03,\r\n    \r\n    /**\r\n     * Apply different jitter ranges based on GPU tier\r\n     */\r\n    jitterByTier: {\r\n      high: 0.02,  // High-end GPUs have less variation (±2%)\r\n      mid: 0.03,   // Mid-range GPUs have medium variation (±3%)\r\n      low: 0.05    // Low-end GPUs have more variation (±5%)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Extension spoofing settings\r\n   */\r\n  extensions: {\r\n    /**\r\n     * Enable extension spoofing\r\n     */\r\n    enabled: true,\r\n    \r\n    /**\r\n     * Extensions to always block\r\n     * These are typically used for fingerprinting\r\n     */\r\n    blockedExtensions: [\r\n      \"WEBGL_debug_renderer_info\",\r\n      \"EXT_disjoint_timer_query\",\r\n      \"EXT_disjoint_timer_query_webgl2\"\r\n    ]\r\n  },\r\n\r\n  /**\r\n   * Draw call spoofing settings\r\n   */\r\n  drawCalls: {\r\n    /**\r\n     * Enable draw call spoofing (shader injection)\r\n     * May impact performance of legitimate WebGL applications\r\n     */\r\n    enabled: false,\r\n    \r\n    /**\r\n     * Noise amount for shader perturbation (0.0 to 1.0)\r\n     * Higher values cause more visible distortion\r\n     */\r\n    noiseAmount: 0.02,\r\n    \r\n    /**\r\n     * Noise granularity (smaller = more fine-grained noise)\r\n     */\r\n    noiseGranularity: 64\r\n  },\r\n\r\n  /**\r\n   * Readback protection settings\r\n   */\r\n  readback: {\r\n    /**\r\n     * Enable readback protection (readPixels/toDataURL)\r\n     */\r\n    enabled: true,\r\n    \r\n    /**\r\n     * Maximum pixel adjustment for noise (0 to 255)\r\n     */\r\n    pixelJitter: 3,\r\n    \r\n    /**\r\n     * Apply noise to alpha channel\r\n     */\r\n    includeAlpha: false\r\n  },\r\n\r\n  /**\r\n   * Debug settings\r\n   */\r\n  debug: {\r\n    /**\r\n     * Enable debug logging\r\n     */\r\n    enabled: false,\r\n    \r\n    /**\r\n     * Log all intercepted WebGL calls\r\n     */\r\n    logCalls: false,\r\n    \r\n    /**\r\n     * Log parameter values (before and after spoofing)\r\n     */\r\n    logParameters: false,\r\n    \r\n    /**\r\n     * Add visual indicator when protection is active\r\n     */\r\n    visualIndicator: false\r\n  }\r\n};\r\n\r\n/**\r\n * Configuration class for WebGL fingerprinting protection\r\n */\r\nclass Config {\r\n  /**\r\n   * Create a new Config instance\r\n   * @param {Object} userConfig - User-provided configuration (will be merged with defaults)\r\n   */\r\n  constructor(userConfig = {}) {\r\n    // Merge default config with user-provided config\r\n    this.config = this._mergeConfigs(defaultConfig, userConfig);\r\n    \r\n    // Freeze the config to prevent changes after initialization\r\n    Object.freeze(this.config);\r\n  }\r\n\r\n  /**\r\n   * Merge configurations, handling nested objects\r\n   * @private\r\n   * @param {Object} defaultConfig - The default configuration\r\n   * @param {Object} userConfig - The user-provided configuration\r\n   * @returns {Object} The merged configuration\r\n   */\r\n  _mergeConfigs(defaultConfig, userConfig) {\r\n    // Create a copy of the default config\r\n    const result = JSON.parse(JSON.stringify(defaultConfig));\r\n    \r\n    // If user config is not an object, return default\r\n    if (!userConfig || typeof userConfig !== 'object') {\r\n      return result;\r\n    }\r\n    \r\n    // Merge top-level properties\r\n    for (const key in userConfig) {\r\n      if (key in result) {\r\n        // Handle nested objects\r\n        if (typeof result[key] === 'object' && result[key] !== null && \r\n            typeof userConfig[key] === 'object' && userConfig[key] !== null) {\r\n          result[key] = this._mergeConfigs(result[key], userConfig[key]);\r\n        } else {\r\n          // Overwrite with user value\r\n          result[key] = userConfig[key];\r\n        }\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get the full configuration object\r\n   * @returns {Object} The complete configuration\r\n   */\r\n  getConfig() {\r\n    return this.config;\r\n  }\r\n\r\n  /**\r\n   * Get a specific configuration value using dot notation\r\n   * @param {string} path - The configuration path (e.g., 'parameters.jitterPercent')\r\n   * @param {*} defaultValue - Default value if path doesn't exist\r\n   * @returns {*} The configuration value\r\n   */\r\n  get(path, defaultValue) {\r\n    const parts = path.split('.');\r\n    let current = this.config;\r\n    \r\n    for (const part of parts) {\r\n      if (current === undefined || current === null || !(part in current)) {\r\n        return defaultValue;\r\n      }\r\n      current = current[part];\r\n    }\r\n    \r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Check if a feature is enabled\r\n   * @param {string} feature - The feature name ('parameters', 'extensions', etc.)\r\n   * @returns {boolean} Whether the feature is enabled\r\n   */\r\n  isEnabled(feature) {\r\n    // Check master switch first\r\n    if (!this.config.enabled) {\r\n      return false;\r\n    }\r\n    \r\n    // Check feature-specific enabled flag\r\n    if (feature && this.config[feature]) {\r\n      return !!this.config[feature].enabled;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Log a debug message if debug is enabled\r\n   * @param {string} message - The message to log\r\n   * @param {string} level - The log level ('log', 'warn', 'error')\r\n   */\r\n  log(message, level = 'log') {\r\n    if (this.config.debug.enabled) {\r\n      console[level](`[WebGL Fingerprint Protection] ${message}`);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Config;","// src/prng.js\r\n\r\n/**\r\n * A seeded pseudo-random number generator for consistent randomness\r\n * This ensures fingerprints remain consistent within a session\r\n */\r\nclass SessionPRNG {\r\n  /**\r\n   * Create a new seeded PRNG\r\n   * @param {string|number} seed - The seed value (if not provided, a random one will be generated)\r\n   */\r\n  constructor(seed) {\r\n    this.seed = seed !== undefined ? seed : this._generateSeed();\r\n    this._state = this._initState(this.seed);\r\n  }\r\n\r\n  /**\r\n   * Generate a random seed if none provided\r\n   * @private\r\n   * @returns {number} A random seed\r\n   */\r\n  _generateSeed() {\r\n    // Generate a timestamp-based seed with some randomness\r\n    return Date.now() ^ (Math.random() * 0x100000000);\r\n  }\r\n\r\n  /**\r\n   * Initialize the PRNG state from a seed\r\n   * @private\r\n   * @param {string|number} seed - The seed value\r\n   * @returns {Array<number>} The initial state array\r\n   */\r\n  _initState(seed) {\r\n    // Convert string seed to number if needed\r\n    let s = seed;\r\n    if (typeof seed === 'string') {\r\n      s = 0;\r\n      for (let i = 0; i < seed.length; i++) {\r\n        s = ((s << 5) - s) + seed.charCodeAt(i);\r\n        s = s >>> 0; // Convert to 32-bit unsigned integer\r\n      }\r\n    }\r\n\r\n    // Create a state array of 4 values\r\n    const state = new Array(4);\r\n    \r\n    // Initialize with LCG\r\n    state[0] = s >>> 0;\r\n    state[1] = (s * 69069 + 1) >>> 0;\r\n    state[2] = (state[1] * 69069 + 1) >>> 0;\r\n    state[3] = (state[2] * 69069 + 1) >>> 0;\r\n    \r\n    // Warm up the state\r\n    for (let i = 0; i < 12; i++) {\r\n      this._next(state);\r\n    }\r\n    \r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Advance the PRNG state\r\n   * @private\r\n   * @param {Array<number>} state - The current state array\r\n   * @returns {number} A random 32-bit number\r\n   */\r\n  _next(state = this._state) {\r\n    // Using xorshift128 algorithm\r\n    let t = state[3];\r\n    let s = state[0];\r\n    \r\n    state[3] = state[2];\r\n    state[2] = state[1];\r\n    state[1] = s;\r\n    \r\n    t ^= t << 11;\r\n    t ^= t >>> 8;\r\n    \r\n    state[0] = t ^ s ^ (s >>> 19);\r\n    \r\n    return state[0] >>> 0;\r\n  }\r\n\r\n  /**\r\n   * Get a random float between 0 (inclusive) and 1 (exclusive)\r\n   * @returns {number} A random float between 0 and 1\r\n   */\r\n  random() {\r\n    return this._next() / 0x100000000;\r\n  }\r\n\r\n  /**\r\n   * Get a random integer between min (inclusive) and max (inclusive)\r\n   * @param {number} min - The minimum value\r\n   * @param {number} max - The maximum value\r\n   * @returns {number} A random integer in the specified range\r\n   */\r\n  randomInt(min, max) {\r\n    return Math.floor(this.random() * (max - min + 1)) + min;\r\n  }\r\n\r\n  /**\r\n   * Get a random float between min (inclusive) and max (exclusive)\r\n   * @param {number} min - The minimum value\r\n   * @param {number} max - The maximum value\r\n   * @returns {number} A random float in the specified range\r\n   */\r\n  randomFloat(min, max) {\r\n    return this.random() * (max - min) + min;\r\n  }\r\n\r\n  /**\r\n   * Select a random item from an array\r\n   * @param {Array} array - The array to select from\r\n   * @returns {*} A random item from the array\r\n   */\r\n  randomChoice(array) {\r\n    if (!array || array.length === 0) {\r\n      return undefined;\r\n    }\r\n    const index = this.randomInt(0, array.length - 1);\r\n    return array[index];\r\n  }\r\n\r\n  /**\r\n   * Shuffle an array in-place using Fisher-Yates algorithm\r\n   * @param {Array} array - The array to shuffle\r\n   * @returns {Array} The shuffled array (same reference)\r\n   */\r\n  shuffle(array) {\r\n    if (!array || array.length <= 1) {\r\n      return array;\r\n    }\r\n    \r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = this.randomInt(0, i);\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    \r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * Create a sub-generator with a derived seed\r\n   * Useful for consistent but different randomness in different contexts\r\n   * @param {string} context - A context string to mix with the original seed\r\n   * @returns {SessionPRNG} A new PRNG with a derived seed\r\n   */\r\n  deriveGenerator(context) {\r\n    const childSeed = `${this.seed}-${context}`;\r\n    return new SessionPRNG(childSeed);\r\n  }\r\n\r\n  /**\r\n * Get the current seed\r\n * @returns {string|number} The seed value\r\n */\r\ngetSeed() {\r\n  return this.seed;\r\n}\r\n}\r\n\r\nmodule.exports = SessionPRNG;","// src/spoofing/drawSpoof.js\r\n\r\n/**\r\n * Draw call spoofing module for WebGL fingerprinting protection\r\n * Injects shader-based noise to modify rendered output\r\n */\r\n\r\n/**\r\n * Install draw call spoofing for a WebGL context\r\n * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context\r\n * @param {Object} profile - The selected GPU profile\r\n * @param {Object} prng - The PRNG instance\r\n * @param {Object} config - The configuration object\r\n * @param {Object} state - Shared state object for cross-module communication\r\n * @returns {boolean} True if spoofing was installed\r\n */\r\nfunction installDrawSpoofing(gl, profile, prng, config, state) {\r\n  if (!gl || !profile || !prng || !config || !state) {\r\n    return false;\r\n  }\r\n\r\n  // Check if draw call spoofing is enabled\r\n  if (!config.isEnabled('drawCalls')) {\r\n    return false;\r\n  }\r\n\r\n  // Store original draw methods\r\n  const originalDrawArrays = gl.drawArrays;\r\n  const originalDrawElements = gl.drawElements;\r\n  const originalDrawArraysInstanced = gl.drawArraysInstanced || gl.drawArraysInstancedANGLE;\r\n  const originalDrawElementsInstanced = gl.drawElementsInstanced || gl.drawElementsInstancedANGLE;\r\n\r\n  // Track whether we've applied noise to this context\r\n  let noiseApplied = false;\r\n\r\n  // Get configuration values\r\n  const noiseAmount = config.get('drawCalls.noiseAmount', 0.02);\r\n  const noiseGranularity = config.get('drawCalls.noiseGranularity', 64);\r\n\r\n  // Create PRNG specifically for noise shader\r\n  const noisePrng = prng.deriveGenerator('draw-noise');\r\n\r\n  /**\r\n   * Vertex shader source for noise overlay\r\n   */\r\n  const noiseVertexShaderSource = `\r\n    attribute vec2 a_position;\r\n    varying vec2 v_texCoord;\r\n    \r\n    void main() {\r\n      v_texCoord = a_position * 0.5 + 0.5;\r\n      gl_Position = vec4(a_position, 0.0, 1.0);\r\n    }\r\n  `;\r\n\r\n  /**\r\n   * Fragment shader source for noise overlay\r\n   */\r\n  const noiseFragmentShaderSource = `\r\n    precision mediump float;\r\n    \r\n    uniform float u_noiseAmount;\r\n    uniform float u_seed;\r\n    uniform vec2 u_noiseScale;\r\n    varying vec2 v_texCoord;\r\n    \r\n    // Pseudo-random function\r\n    float rand(vec2 co) {\r\n      return fract(sin(dot(co.xy, vec2(12.9898, 78.233)) * u_seed) * 43758.5453);\r\n    }\r\n    \r\n    void main() {\r\n      // Create grid-based noise\r\n      vec2 noiseCoord = floor(v_texCoord * u_noiseScale) / u_noiseScale;\r\n      float noise = rand(noiseCoord) * u_noiseAmount;\r\n      \r\n      // Subtle RGB noise adjustment\r\n      vec3 noiseColor = vec3(\r\n        rand(noiseCoord + vec2(0.1, 0.0)) * u_noiseAmount,\r\n        rand(noiseCoord + vec2(0.0, 0.1)) * u_noiseAmount,\r\n        rand(noiseCoord + vec2(0.1, 0.1)) * u_noiseAmount\r\n      );\r\n      \r\n      // Apply noise to fragment color\r\n      gl_FragColor = vec4(noiseColor - (u_noiseAmount * 0.5), 0.0);\r\n    }\r\n  `;\r\n\r\n  /**\r\n   * Create and compile a shader\r\n   * @param {number} type - The shader type\r\n   * @param {string} source - The shader source code\r\n   * @returns {WebGLShader} The compiled shader\r\n   */\r\n  function createShader(type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    \r\n    // Check for compilation errors\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      const error = gl.getShaderInfoLog(shader);\r\n      config.log(`Shader compilation failed: ${error}`, 'error');\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    \r\n    return shader;\r\n  }\r\n\r\n  /**\r\n   * Create the noise shader program\r\n   * @returns {Object} The shader program and attributes/uniforms\r\n   */\r\n  function createNoiseProgram() {\r\n    // Create and compile shaders\r\n    const vertexShader = createShader(gl.VERTEX_SHADER, noiseVertexShaderSource);\r\n    const fragmentShader = createShader(gl.FRAGMENT_SHADER, noiseFragmentShaderSource);\r\n    \r\n    if (!vertexShader || !fragmentShader) {\r\n      return null;\r\n    }\r\n    \r\n    // Create and link program\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    \r\n    // Check for linking errors\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      const error = gl.getProgramInfoLog(program);\r\n      config.log(`Program linking failed: ${error}`, 'error');\r\n      gl.deleteProgram(program);\r\n      gl.deleteShader(vertexShader);\r\n      gl.deleteShader(fragmentShader);\r\n      return null;\r\n    }\r\n    \r\n    // Get attribute and uniform locations\r\n    const positionAttribute = gl.getAttribLocation(program, 'a_position');\r\n    const noiseAmountUniform = gl.getUniformLocation(program, 'u_noiseAmount');\r\n    const seedUniform = gl.getUniformLocation(program, 'u_seed');\r\n    const noiseScaleUniform = gl.getUniformLocation(program, 'u_noiseScale');\r\n    \r\n    return {\r\n      program,\r\n      attributes: {\r\n        position: positionAttribute\r\n      },\r\n      uniforms: {\r\n        noiseAmount: noiseAmountUniform,\r\n        seed: seedUniform,\r\n        noiseScale: noiseScaleUniform\r\n      },\r\n      vertexShader,\r\n      fragmentShader\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply noise to the current framebuffer\r\n   */\r\n  function applyNoise() {\r\n    // Skip if we've already applied noise\r\n    if (noiseApplied) {\r\n      return;\r\n    }\r\n    \r\n    // Save current WebGL state\r\n    const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\r\n    const currentBlend = gl.getParameter(gl.BLEND);\r\n    const currentBlendSrcRGB = gl.getParameter(gl.BLEND_SRC_RGB);\r\n    const currentBlendDstRGB = gl.getParameter(gl.BLEND_DST_RGB);\r\n    const currentViewport = gl.getParameter(gl.VIEWPORT);\r\n    const currentArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);\r\n    const currentActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);\r\n    const currentAttribState = [];\r\n    \r\n    // Create noise program if we haven't already\r\n    const noiseProgram = createNoiseProgram();\r\n    if (!noiseProgram) {\r\n      config.log('Failed to create noise program', 'error');\r\n      return;\r\n    }\r\n    \r\n    // Save attribute states\r\n    const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\r\n    for (let i = 0; i < maxVertexAttribs; i++) {\r\n      currentAttribState[i] = gl.getVertexAttrib(i, gl.VERTEX_ATTRIB_ARRAY_ENABLED);\r\n    }\r\n    \r\n    try {\r\n      // Set up additive blending\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.ONE, gl.ONE);\r\n      \r\n      // Use noise program\r\n      gl.useProgram(noiseProgram.program);\r\n      \r\n      // Set uniforms\r\n      gl.uniform1f(noiseProgram.uniforms.noiseAmount, noiseAmount);\r\n      gl.uniform1f(noiseProgram.uniforms.seed, noisePrng.random() * 100);\r\n      gl.uniform2f(noiseProgram.uniforms.noiseScale, noiseGranularity, noiseGranularity);\r\n      \r\n      // Create quad vertices\r\n      const buffer = gl.createBuffer();\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        -1, -1,\r\n         1, -1,\r\n        -1,  1,\r\n         1,  1\r\n      ]), gl.STATIC_DRAW);\r\n      \r\n      // Set up attribute\r\n      gl.enableVertexAttribArray(noiseProgram.attributes.position);\r\n      gl.vertexAttribPointer(noiseProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\r\n      \r\n      // Draw fullscreen quad\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n      \r\n      // Clean up\r\n      gl.disableVertexAttribArray(noiseProgram.attributes.position);\r\n      gl.deleteBuffer(buffer);\r\n      \r\n      // Mark as applied\r\n      noiseApplied = true;\r\n      state.noiseApplied = true;\r\n      \r\n      // Debug logging\r\n      config.log('Applied noise to WebGL context');\r\n    } catch (error) {\r\n      config.log(`Error applying noise: ${error.message}`, 'error');\r\n    } finally {\r\n      // Restore previous state\r\n      gl.useProgram(currentProgram);\r\n      \r\n      if (!currentBlend) {\r\n        gl.disable(gl.BLEND);\r\n      } else {\r\n        gl.blendFunc(currentBlendSrcRGB, currentBlendDstRGB);\r\n      }\r\n      \r\n      gl.bindBuffer(gl.ARRAY_BUFFER, currentArrayBuffer);\r\n      gl.activeTexture(currentActiveTexture);\r\n      \r\n      // Restore attribute states\r\n      for (let i = 0; i < maxVertexAttribs; i++) {\r\n        if (currentAttribState[i]) {\r\n          gl.enableVertexAttribArray(i);\r\n        } else {\r\n          gl.disableVertexAttribArray(i);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if a draw call is significant enough to apply noise\r\n   * @param {number} count - The number of vertices/elements to draw\r\n   * @returns {boolean} True if significant\r\n   */\r\n  function isSignificantDrawCall(count) {\r\n    // Consider draws with more than 10 vertices significant\r\n    return count > 10;\r\n  }\r\n\r\n  /**\r\n   * Override drawArrays method\r\n   */\r\n  gl.drawArrays = function(mode, first, count) {\r\n    // Apply noise if this is a significant draw\r\n    if (isSignificantDrawCall(count)) {\r\n      applyNoise();\r\n    }\r\n    \r\n    // Call original method\r\n    return originalDrawArrays.call(this, mode, first, count);\r\n  };\r\n\r\n  /**\r\n   * Override drawElements method\r\n   */\r\n  gl.drawElements = function(mode, count, type, offset) {\r\n    // Apply noise if this is a significant draw\r\n    if (isSignificantDrawCall(count)) {\r\n      applyNoise();\r\n    }\r\n    \r\n    // Call original method\r\n    return originalDrawElements.call(this, mode, count, type, offset);\r\n  };\r\n\r\n  // Handle instanced draw calls if available\r\n  if (originalDrawArraysInstanced) {\r\n    gl.drawArraysInstanced = function(mode, first, count, instanceCount) {\r\n      // Apply noise if this is a significant draw\r\n      if (isSignificantDrawCall(count * instanceCount)) {\r\n        applyNoise();\r\n      }\r\n      \r\n      // Call original method\r\n      return originalDrawArraysInstanced.call(this, mode, first, count, instanceCount);\r\n    };\r\n  }\r\n\r\n  if (originalDrawElementsInstanced) {\r\n    gl.drawElementsInstanced = function(mode, count, type, offset, instanceCount) {\r\n      // Apply noise if this is a significant draw\r\n      if (isSignificantDrawCall(count * instanceCount)) {\r\n        applyNoise();\r\n      }\r\n      \r\n      // Call original method\r\n      return originalDrawElementsInstanced.call(this, mode, count, type, offset, instanceCount);\r\n    };\r\n  }\r\n\r\n  // Handle ANGLE instanced extensions\r\n  const angleInstancedArrays = gl.getExtension('ANGLE_instanced_arrays');\r\n  if (angleInstancedArrays) {\r\n    const originalDrawArraysInstancedANGLE = angleInstancedArrays.drawArraysInstancedANGLE;\r\n    const originalDrawElementsInstancedANGLE = angleInstancedArrays.drawElementsInstancedANGLE;\r\n    \r\n    angleInstancedArrays.drawArraysInstancedANGLE = function(mode, first, count, instanceCount) {\r\n      // Apply noise if this is a significant draw\r\n      if (isSignificantDrawCall(count * instanceCount)) {\r\n        applyNoise();\r\n      }\r\n      \r\n      // Call original method\r\n      return originalDrawArraysInstancedANGLE.call(this, mode, first, count, instanceCount);\r\n    };\r\n    \r\n    angleInstancedArrays.drawElementsInstancedANGLE = function(mode, count, type, offset, instanceCount) {\r\n      // Apply noise if this is a significant draw\r\n      if (isSignificantDrawCall(count * instanceCount)) {\r\n        applyNoise();\r\n      }\r\n      \r\n      // Call original method\r\n      return originalDrawElementsInstancedANGLE.call(this, mode, count, type, offset, instanceCount);\r\n    };\r\n  }\r\n\r\n  // Log successful installation\r\n  config.log('Draw call spoofing installed');\r\n  \r\n  return true;\r\n}\r\n\r\nmodule.exports = {\r\n  installDrawSpoofing\r\n};","// src/spoofing/extensionSpoof.js\r\n\r\n/**\r\n * Extension spoofing module for WebGL fingerprinting protection\r\n * Intercepts and modifies getSupportedExtensions() and getExtension() calls\r\n */\r\n\r\n/**\r\n * Install extension spoofing for a WebGL context\r\n * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context\r\n * @param {Object} profile - The selected GPU profile\r\n * @param {Object} prng - The PRNG instance\r\n * @param {Object} config - The configuration object\r\n * @returns {boolean} True if spoofing was installed\r\n */\r\nfunction installExtensionSpoofing(gl, profile, prng, config) {\r\n  if (!gl || !profile || !prng || !config) {\r\n    return false;\r\n  }\r\n\r\n  // Check if extension spoofing is enabled\r\n  if (!config.isEnabled('extensions')) {\r\n    return false;\r\n  }\r\n\r\n  // Determine if this is a WebGL2 context\r\n  const isWebGL2 = !!gl.createQuery;\r\n\r\n  // Get blocked extensions from config\r\n  const blockedExtensions = config.get('extensions.blockedExtensions', []);\r\n  \r\n  // Store original methods\r\n  const originalGetSupportedExtensions = gl.getSupportedExtensions;\r\n  const originalGetExtension = gl.getExtension;\r\n\r\n  // Extension cache to ensure consistent responses\r\n  const extensionCache = new Map();\r\n  \r\n  // Track which extensions have been excluded from the supported list\r\n  const excludedExtensions = new Set();\r\n\r\n  /**\r\n   * Get a filtered list of extensions based on the profile and blocked list\r\n   * @returns {string[]} Array of extension names\r\n   */\r\n  function getFilteredExtensions() {\r\n    // Get the actual supported extensions\r\n    const actualExtensions = originalGetSupportedExtensions.call(gl);\r\n    \r\n    // No extensions? Return empty array\r\n    if (!actualExtensions || actualExtensions.length === 0) {\r\n      return [];\r\n    }\r\n    \r\n    // Get extensions from profile\r\n    const profileExtensions = isWebGL2 \r\n      ? [...profile.extensions, ...profile.webgl2Extensions]\r\n      : profile.extensions;\r\n    \r\n    // Filter extensions\r\n    const filteredExtensions = actualExtensions.filter(ext => {\r\n      // Block explicitly blocked extensions\r\n      if (blockedExtensions.includes(ext)) {\r\n        excludedExtensions.add(ext);\r\n        return false;\r\n      }\r\n      \r\n      // If we have profile extensions, only include extensions in our profile\r\n      if (profileExtensions && profileExtensions.length > 0) {\r\n        const included = profileExtensions.includes(ext);\r\n        if (!included) {\r\n          excludedExtensions.add(ext);\r\n        }\r\n        return included;\r\n      }\r\n      \r\n      // Default to allowing the extension\r\n      return true;\r\n    });\r\n    \r\n    return filteredExtensions;\r\n  }\r\n\r\n  /**\r\n   * Override getSupportedExtensions method\r\n   * @returns {string[]} Array of extension names\r\n   */\r\n  gl.getSupportedExtensions = function() {\r\n    const filteredExtensions = getFilteredExtensions();\r\n    \r\n    // Debug logging\r\n    if (config.get('debug.enabled')) {\r\n      const actualExtensions = originalGetSupportedExtensions.call(gl);\r\n      const blocked = actualExtensions.filter(ext => !filteredExtensions.includes(ext));\r\n      \r\n      if (blocked.length > 0) {\r\n        config.log(`Blocked extensions: ${blocked.join(', ')}`, 'log');\r\n      }\r\n      \r\n      config.log(`Supported extensions: ${filteredExtensions.length} (original: ${actualExtensions.length})`, 'log');\r\n    }\r\n    \r\n    return filteredExtensions;\r\n  };\r\n\r\n  /**\r\n * Override getExtension method\r\n * @param {string} name - Extension name\r\n * @returns {Object|null} The extension object or null\r\n */\r\ngl.getExtension = function(name) {\r\n  // Check cache first for consistency\r\n  if (extensionCache.has(name)) {\r\n    return extensionCache.get(name);\r\n  }\r\n  \r\n  // Block explicitly blocked extensions\r\n  if (blockedExtensions.includes(name)) {\r\n    // Debug logging\r\n    if (config.get('debug.enabled')) {\r\n      config.log(`Blocked extension: ${name}`, 'log');\r\n    }\r\n    \r\n    // Cache and return null\r\n    extensionCache.set(name, null);\r\n    return null;\r\n  }\r\n  \r\n  // If it was excluded from supported extensions, return null\r\n  if (excludedExtensions.has(name)) {\r\n    extensionCache.set(name, null);\r\n    return null;\r\n  }\r\n  \r\n  // Critical fingerprinting extensions should always be blocked\r\n  // This is a safeguard in case they're not in blockedExtensions\r\n  if (name === 'WEBGL_debug_renderer_info') {\r\n    config.log('Critical fingerprinting extension blocked: WEBGL_debug_renderer_info', 'warn');\r\n    extensionCache.set(name, null);\r\n    return null;\r\n  }\r\n  \r\n  // Otherwise get the real extension\r\n  const result = originalGetExtension.call(gl, name);\r\n  \r\n  // Cache the result\r\n  extensionCache.set(name, result);\r\n  \r\n  return result;\r\n};\r\n\r\n  // Log successful installation\r\n  config.log('Extension spoofing installed');\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Get WebGL extensions commonly supported by a specific vendor\r\n * @param {string} vendor - The GPU vendor ('nvidia', 'amd', 'intel')\r\n * @param {boolean} isWebGL2 - Whether this is for WebGL2\r\n * @returns {string[]} Array of extension names\r\n */\r\nfunction getVendorExtensions(vendor, isWebGL2) {\r\n  // Common extensions most GPUs support\r\n  const commonExtensions = [\r\n    \"ANGLE_instanced_arrays\",\r\n    \"EXT_blend_minmax\",\r\n    \"EXT_color_buffer_half_float\",\r\n    \"EXT_float_blend\",\r\n    \"OES_element_index_uint\",\r\n    \"OES_standard_derivatives\",\r\n    \"OES_texture_float\",\r\n    \"OES_texture_float_linear\",\r\n    \"OES_texture_half_float\",\r\n    \"OES_texture_half_float_linear\",\r\n    \"OES_vertex_array_object\",\r\n    \"WEBGL_color_buffer_float\",\r\n    \"WEBGL_lose_context\"\r\n  ];\r\n\r\n  // Vendor-specific extensions for WebGL1\r\n  const vendorExtensions = {\r\n    nvidia: [\r\n      \"EXT_texture_filter_anisotropic\",\r\n      \"WEBGL_compressed_texture_s3tc\",\r\n      \"WEBGL_compressed_texture_s3tc_srgb\",\r\n      \"WEBGL_debug_shaders\"\r\n    ],\r\n    amd: [\r\n      \"EXT_texture_filter_anisotropic\",\r\n      \"WEBGL_compressed_texture_s3tc\",\r\n      \"WEBGL_compressed_texture_s3tc_srgb\",\r\n      \"WEBGL_debug_shaders\"\r\n    ],\r\n    intel: [\r\n      \"EXT_texture_filter_anisotropic\",\r\n      \"WEBGL_compressed_texture_s3tc\"\r\n    ],\r\n    generic: []\r\n  };\r\n\r\n  // Additional extensions for WebGL2\r\n  const webgl2Extensions = [\r\n    \"EXT_color_buffer_float\",\r\n    \"EXT_texture_filter_anisotropic\",\r\n    \"OES_draw_buffers_indexed\",\r\n    \"WEBGL_compressed_texture_s3tc\",\r\n    \"WEBGL_compressed_texture_s3tc_srgb\",\r\n    \"WEBGL_debug_shaders\"\r\n  ];\r\n\r\n  // Vendor-specific WebGL2 extensions\r\n  const vendorWebGL2Extensions = {\r\n    nvidia: [\r\n      \"WEBGL_compressed_texture_astc\",\r\n      \"WEBGL_compressed_texture_etc\"\r\n    ],\r\n    amd: [\r\n      \"WEBGL_compressed_texture_astc\",\r\n      \"WEBGL_compressed_texture_etc\"\r\n    ],\r\n    intel: [],\r\n    generic: []\r\n  };\r\n\r\n  // Get the appropriate extension list\r\n  const baseExtensions = [\r\n    ...commonExtensions,\r\n    ...(vendorExtensions[vendor] || vendorExtensions.generic)\r\n  ];\r\n\r\n  // Add WebGL2 extensions if applicable\r\n  if (isWebGL2) {\r\n    return [\r\n      ...baseExtensions,\r\n      ...webgl2Extensions,\r\n      ...(vendorWebGL2Extensions[vendor] || vendorWebGL2Extensions.generic)\r\n    ];\r\n  }\r\n\r\n  return baseExtensions;\r\n}\r\n\r\nmodule.exports = {\r\n  installExtensionSpoofing,\r\n  getVendorExtensions\r\n};","// src/spoofing/parameterSpoof.js\r\n\r\n/**\r\n * Parameter spoofing module for WebGL fingerprinting protection\r\n * Intercepts and modifies getParameter() and getShaderPrecisionFormat() calls\r\n */\r\n\r\n/**\r\n * Install parameter spoofing for a WebGL context\r\n * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context\r\n * @param {Object} profile - The selected GPU profile\r\n * @param {Object} prng - The PRNG instance\r\n * @param {Object} config - The configuration object\r\n * @returns {boolean} True if spoofing was installed\r\n */\r\nfunction installParameterSpoofing(gl, profile, prng, config) {\r\n  if (!gl || !profile || !prng || !config) {\r\n    return false;\r\n  }\r\n\r\n  // Check if spoofing is enabled\r\n  if (!config.isEnabled('parameters')) {\r\n    return false;\r\n  }\r\n\r\n  // Determine if this is a WebGL2 context\r\n  const isWebGL2 = !!gl.createQuery;\r\n\r\n  // Create parameter cache to ensure consistent values\r\n  const parameterCache = new Map();\r\n\r\n  // Store original methods\r\n  const originalGetParameter = gl.getParameter;\r\n  const originalGetShaderPrecisionFormat = gl.getShaderPrecisionFormat;\r\n\r\n  // Get jitter percentage based on GPU tier\r\n  const jitterPercent = config.get(`parameters.jitterByTier.${profile.gpuTier}`, \r\n                                   config.get('parameters.jitterPercent', 0.03));\r\n\r\n  // Constants for WEBGL_debug_renderer_info extension\r\n  const UNMASKED_VENDOR_WEBGL = 0x9245;\r\n  const UNMASKED_RENDERER_WEBGL = 0x9246;\r\n\r\n  /**\r\n   * Apply consistent jitter to a numeric value\r\n   * @param {number} value - The base value\r\n   * @param {string} paramName - The parameter name or key\r\n   * @returns {number} The jittered value\r\n   */\r\n  function applyJitter(value, paramName) {\r\n    if (typeof value !== 'number' || jitterPercent <= 0) {\r\n      return value;\r\n    }\r\n\r\n    // Create a parameter-specific sub-PRNG\r\n    const paramPrng = prng.deriveGenerator(`param-${paramName}`);\r\n    \r\n    // Generate jitter factor between -jitterPercent and +jitterPercent\r\n    const jitterFactor = 1 + (paramPrng.random() * 2 - 1) * jitterPercent;\r\n    \r\n    // Apply jitter and round to nearest integer if original value was an integer\r\n    const jitteredValue = value * jitterFactor;\r\n    return Number.isInteger(value) ? Math.floor(jitteredValue) : jitteredValue;\r\n  }\r\n\r\n  /**\r\n   * Apply jitter to array values\r\n   * @param {Array} array - The array to jitter\r\n   * @param {string} paramName - The parameter name\r\n   * @returns {Array} The jittered array\r\n   */\r\n  function applyJitterToArray(array, paramName) {\r\n    if (!Array.isArray(array)) {\r\n      return array;\r\n    }\r\n\r\n    return array.map((value, index) => {\r\n      return applyJitter(value, `${paramName}[${index}]`);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Override getParameter method\r\n   * @param {number} pname - The parameter name (GL enum)\r\n   * @returns {*} The parameter value\r\n   */\r\n  gl.getParameter = function(pname) {\r\n    // Convert pname to string for cache key and logging\r\n    const pnameStr = pname.toString();\r\n    \r\n    // Check cache first for consistency\r\n    if (parameterCache.has(pnameStr)) {\r\n      return parameterCache.get(pnameStr);\r\n    }\r\n\r\n    // Debug logging\r\n    if (config.get('debug.logParameters')) {\r\n      const origValue = originalGetParameter.call(this, pname);\r\n      config.log(`getParameter(${pnameStr}) original: ${JSON.stringify(origValue)}`);\r\n    }\r\n\r\n    let result;\r\n\r\n    // Handle WEBGL_debug_renderer_info parameters\r\n    if (pname === UNMASKED_VENDOR_WEBGL) {\r\n      result = profile.unmaskedVendor;\r\n    } \r\n    else if (pname === UNMASKED_RENDERER_WEBGL) {\r\n      result = profile.unmaskedRenderer;\r\n    }\r\n    // Handle standard parameters\r\n    else if (pname === this.VENDOR) {\r\n      result = profile.vendor;\r\n    } \r\n    else if (pname === this.RENDERER) {\r\n      result = profile.renderer;\r\n    } \r\n    else if (pname === this.VERSION) {\r\n      result = profile.version;\r\n    } \r\n    else if (pname === this.SHADING_LANGUAGE_VERSION) {\r\n      result = profile.shadingLanguage;\r\n    }\r\n    // Handle parameters from profile\r\n    else {\r\n      // Get parameter from profile first\r\n      const paramSet = isWebGL2 ? {...profile.parameters, ...profile.webgl2Parameters} : profile.parameters;\r\n      \r\n      if (paramSet && pnameStr in paramSet) {\r\n        const baseValue = paramSet[pnameStr];\r\n        \r\n        // Apply jitter based on value type\r\n        if (Array.isArray(baseValue)) {\r\n          result = applyJitterToArray(baseValue, pnameStr);\r\n        } else {\r\n          result = applyJitter(baseValue, pnameStr);\r\n        }\r\n      } \r\n      // Fall back to real value if not in profile\r\n      else {\r\n        result = originalGetParameter.call(this, pname);\r\n      }\r\n    }\r\n\r\n    // Store in cache for consistent responses\r\n    parameterCache.set(pnameStr, result);\r\n    \r\n    // Debug logging\r\n    if (config.get('debug.logParameters')) {\r\n      config.log(`getParameter(${pnameStr}) spoofed: ${JSON.stringify(result)}`);\r\n    }\r\n    \r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Shader precision format cache to ensure consistency\r\n   */\r\n  const shaderPrecisionCache = new Map();\r\n\r\n  /**\r\n   * Override getShaderPrecisionFormat method\r\n   * @param {number} shaderType - The shader type\r\n   * @param {number} precisionType - The precision type\r\n   * @returns {WebGLShaderPrecisionFormat} The precision format\r\n   */\r\n  gl.getShaderPrecisionFormat = function(shaderType, precisionType) {\r\n    // Create cache key\r\n    const cacheKey = `${shaderType}-${precisionType}`;\r\n    \r\n    // Check cache first\r\n    if (shaderPrecisionCache.has(cacheKey)) {\r\n      return shaderPrecisionCache.get(cacheKey);\r\n    }\r\n\r\n    // Get the original precision format\r\n    const originalFormat = originalGetShaderPrecisionFormat.call(this, shaderType, precisionType);\r\n    \r\n    // If we couldn't get the original format, return it as is\r\n    if (!originalFormat) {\r\n      return originalFormat;\r\n    }\r\n    \r\n    // Create a new format with jittered values\r\n    const jitteredFormat = {\r\n      precision: applyJitter(originalFormat.precision, `${cacheKey}-precision`),\r\n      rangeMin: originalFormat.rangeMin, // Keep min range intact\r\n      rangeMax: applyJitter(originalFormat.rangeMax, `${cacheKey}-rangeMax`)\r\n    };\r\n    \r\n    // WebGLShaderPrecisionFormat is not a plain object, so we need to wrap it\r\n    const result = {\r\n      precision: jitteredFormat.precision,\r\n      rangeMin: jitteredFormat.rangeMin,\r\n      rangeMax: jitteredFormat.rangeMax\r\n    };\r\n    \r\n    // Store in cache\r\n    shaderPrecisionCache.set(cacheKey, result);\r\n    \r\n    return result;\r\n  };\r\n\r\n  // Log successful installation\r\n  config.log('Parameter spoofing installed');\r\n  \r\n  return true;\r\n}\r\n\r\nmodule.exports = {\r\n  installParameterSpoofing\r\n};","// src/spoofing/readbackSpoof.js\r\n\r\n/**\r\n * Readback spoofing module for WebGL fingerprinting protection\r\n * Intercepts and modifies readPixels, toDataURL, and toBlob to ensure\r\n * fingerprinting reads receive modified data\r\n */\r\n\r\n/**\r\n * Install readback spoofing for a WebGL context\r\n * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context\r\n * @param {Object} profile - The selected GPU profile\r\n * @param {Object} prng - The PRNG instance\r\n * @param {Object} config - The configuration object\r\n * @param {Object} state - Shared state object for cross-module communication\r\n * @returns {boolean} True if spoofing was installed\r\n */\r\nfunction installReadbackSpoofing(gl, profile, prng, config, state) {\r\n  if (!gl || !profile || !prng || !config || !state) {\r\n    return false;\r\n  }\r\n\r\n  // Check if readback protection is enabled\r\n  if (!config.isEnabled('readback')) {\r\n    return false;\r\n  }\r\n\r\n  // Get configuration values\r\n  const pixelJitter = config.get('readback.pixelJitter', 3);\r\n  const includeAlpha = config.get('readback.includeAlpha', false);\r\n  \r\n  // Store original methods\r\n  const originalReadPixels = gl.readPixels;\r\n  \r\n  // Get canvas element\r\n  const canvas = gl.canvas;\r\n  if (!canvas) {\r\n    config.log('No canvas found for WebGL context', 'warn');\r\n    return false;\r\n  }\r\n  \r\n  // Store original canvas methods\r\n  const originalToDataURL = canvas.toDataURL;\r\n  const originalToBlob = canvas.toBlob;\r\n  \r\n  // Create a PRNG specifically for pixel noise\r\n  const pixelPrng = prng.deriveGenerator('readback-noise');\r\n\r\n  /**\r\n   * Apply consistent noise to pixel data\r\n   * @param {ArrayBufferView} pixels - The pixel data\r\n   * @param {number} width - The width of the image\r\n   * @param {number} height - The height of the image\r\n   * @param {number} format - The pixel format (gl.RGBA, gl.RGB, etc.)\r\n   */\r\n  function applyPixelNoise(pixels, width, height, format) {\r\n    // Skip if not a typed array\r\n    if (!ArrayBuffer.isView(pixels)) {\r\n      return;\r\n    }\r\n    \r\n    // Determine components per pixel based on format\r\n    let componentsPerPixel = 4; // default for RGBA\r\n    if (format === gl.RGB) {\r\n      componentsPerPixel = 3;\r\n    } else if (format === gl.ALPHA || format === gl.LUMINANCE) {\r\n      componentsPerPixel = 1;\r\n    } else if (format === gl.LUMINANCE_ALPHA) {\r\n      componentsPerPixel = 2;\r\n    }\r\n    \r\n    // Apply consistent noise to each pixel\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        // Calculate base index in the pixel array\r\n        const baseIndex = (y * width + x) * componentsPerPixel;\r\n        \r\n        // Get a consistent noise value for this pixel\r\n        const pixelSeed = `${x},${y}-${pixelPrng.getSeed()}`;\r\n        const pixelNoisePrng = prng.deriveGenerator(pixelSeed);\r\n        \r\n        // Apply noise to each component\r\n        for (let c = 0; c < componentsPerPixel; c++) {\r\n          // Skip alpha channel if configured to do so\r\n          if (c === 3 && !includeAlpha) {\r\n            continue;\r\n          }\r\n          \r\n          // Get consistent noise value for this component\r\n          const componentNoise = Math.floor(pixelNoisePrng.random() * (pixelJitter * 2 + 1)) - pixelJitter;\r\n          \r\n          // Bounds check\r\n          if (baseIndex + c < pixels.length) {\r\n            // Apply noise differently based on array type\r\n            if (pixels instanceof Uint8Array || pixels instanceof Uint8ClampedArray) {\r\n              // 8-bit per channel (0-255)\r\n              pixels[baseIndex + c] = Math.max(0, Math.min(255, pixels[baseIndex + c] + componentNoise));\r\n            } else if (pixels instanceof Float32Array) {\r\n              // Float values (0.0-1.0)\r\n              pixels[baseIndex + c] = Math.max(0, Math.min(1, pixels[baseIndex + c] + (componentNoise / 255)));\r\n            } else {\r\n              // Other types (Uint16Array, etc.)\r\n              // Adjust noise based on maximum value for the type\r\n              const maxValue = Math.pow(2, (pixels.BYTES_PER_ELEMENT * 8)) - 1;\r\n              const typeNoise = Math.floor(componentNoise * (maxValue / 255));\r\n              pixels[baseIndex + c] = Math.max(0, Math.min(maxValue, pixels[baseIndex + c] + typeNoise));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Override readPixels method\r\n   */\r\n  gl.readPixels = function(x, y, width, height, format, type, pixels) {\r\n    // Call original method first\r\n    originalReadPixels.call(this, x, y, width, height, format, type, pixels);\r\n    \r\n    // Skip modification if draw call spoofing has already been applied\r\n    if (state.noiseApplied) {\r\n      config.log('Skipping readPixels noise (already applied by draw spoofing)');\r\n      return;\r\n    }\r\n    \r\n    // Apply noise to the pixel data\r\n    applyPixelNoise(pixels, width, height, format);\r\n    \r\n    // Debug logging\r\n    config.log(`Applied noise to readPixels (${width}x${height})`);\r\n  };\r\n\r\n  /**\r\n   * Apply noise to image data\r\n   * @param {ImageData} imageData - The image data to modify\r\n   */\r\n  function applyImageDataNoise(imageData) {\r\n    if (!imageData || !imageData.data) {\r\n      return;\r\n    }\r\n    \r\n    // Apply noise to the image data\r\n    applyPixelNoise(imageData.data, imageData.width, imageData.height, gl.RGBA);\r\n  }\r\n\r\n  /**\r\n   * Override toDataURL method\r\n   */\r\n  canvas.toDataURL = function(...args) {\r\n    // Skip modification if draw call spoofing has already been applied\r\n    if (state.noiseApplied) {\r\n      return originalToDataURL.apply(this, args);\r\n    }\r\n    \r\n    // Create a temporary canvas to modify the data\r\n    const tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = this.width;\r\n    tempCanvas.height = this.height;\r\n    \r\n    // Copy content to temp canvas\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.drawImage(this, 0, 0);\r\n    \r\n    // Get image data and apply noise\r\n    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n    applyImageDataNoise(imageData);\r\n    \r\n    // Put modified data back\r\n    tempCtx.putImageData(imageData, 0, 0);\r\n    \r\n    // Generate data URL from modified canvas\r\n    return originalToDataURL.apply(tempCanvas, args);\r\n  };\r\n\r\n  /**\r\n   * Override toBlob method if available\r\n   */\r\n  if (originalToBlob) {\r\n    canvas.toBlob = function(callback, ...args) {\r\n      // Skip modification if draw call spoofing has already been applied\r\n      if (state.noiseApplied) {\r\n        return originalToBlob.apply(this, [callback, ...args]);\r\n      }\r\n      \r\n      // Create a temporary canvas to modify the data\r\n      const tempCanvas = document.createElement('canvas');\r\n      tempCanvas.width = this.width;\r\n      tempCanvas.height = this.height;\r\n      \r\n      // Copy content to temp canvas\r\n      const tempCtx = tempCanvas.getContext('2d');\r\n      tempCtx.drawImage(this, 0, 0);\r\n      \r\n      // Get image data and apply noise\r\n      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n      applyImageDataNoise(imageData);\r\n      \r\n      // Put modified data back\r\n      tempCtx.putImageData(imageData, 0, 0);\r\n      \r\n      // Generate blob from modified canvas\r\n      return originalToBlob.apply(tempCanvas, [callback, ...args]);\r\n    };\r\n  }\r\n\r\n  // Log successful installation\r\n  config.log('Readback spoofing installed');\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Helper function to apply noise to a data URL (for iframe fingerprinting protection)\r\n * @param {string} dataURL - The data URL to modify\r\n * @param {Object} prng - The PRNG instance\r\n * @param {Object} config - The configuration object\r\n * @returns {Promise<string>} The modified data URL\r\n */\r\nasync function applyNoiseToDataURL(dataURL, prng, config) {\r\n  // Skip if not a data URL or not a PNG image\r\n  if (!dataURL || !dataURL.startsWith('data:image/png')) {\r\n    return dataURL;\r\n  }\r\n  \r\n  // Create an image from the data URL\r\n  const img = new Image();\r\n  \r\n  // Wait for the image to load using a promise\r\n  const imageLoaded = new Promise((resolve, reject) => {\r\n    img.onload = () => resolve();\r\n    img.onerror = () => reject(new Error('Failed to load image from data URL'));\r\n    img.src = dataURL;\r\n  });\r\n  \r\n  try {\r\n    // Wait for the image to load\r\n    await imageLoaded;\r\n    \r\n    // Create a canvas to draw the image\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = img.width || 300;\r\n    canvas.height = img.height || 150;\r\n    \r\n    // Draw the image to the canvas\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.drawImage(img, 0, 0);\r\n    \r\n    // Get image data\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    \r\n    // Get configuration values\r\n    const pixelJitter = config.get('readback.pixelJitter', 3);\r\n    const includeAlpha = config.get('readback.includeAlpha', false);\r\n    \r\n    // Create a PRNG specifically for pixel noise\r\n    const pixelPrng = prng.deriveGenerator('dataurl-noise');\r\n    \r\n    // Apply noise to each pixel\r\n    for (let y = 0; y < imageData.height; y++) {\r\n      for (let x = 0; x < imageData.width; x++) {\r\n        // Calculate base index in the pixel array\r\n        const baseIndex = (y * imageData.width + x) * 4;\r\n        \r\n        // Get a consistent noise value for this pixel\r\n        const pixelSeed = `${x},${y}-${pixelPrng.getSeed()}`;\r\n        const pixelNoisePrng = prng.deriveGenerator(pixelSeed);\r\n        \r\n        // Apply noise to RGB channels\r\n        for (let c = 0; c < 3; c++) {\r\n          const componentNoise = Math.floor(pixelNoisePrng.random() * (pixelJitter * 2 + 1)) - pixelJitter;\r\n          imageData.data[baseIndex + c] = Math.max(0, Math.min(255, imageData.data[baseIndex + c] + componentNoise));\r\n        }\r\n        \r\n        // Apply noise to alpha channel if configured\r\n        if (includeAlpha) {\r\n          const alphaNoise = Math.floor(pixelNoisePrng.random() * (pixelJitter + 1)) - Math.floor(pixelJitter / 2);\r\n          imageData.data[baseIndex + 3] = Math.max(0, Math.min(255, imageData.data[baseIndex + 3] + alphaNoise));\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Put the modified image data back\r\n    ctx.putImageData(imageData, 0, 0);\r\n    \r\n    // Return the modified data URL\r\n    return canvas.toDataURL('image/png');\r\n  } catch (error) {\r\n    console.error('Error applying noise to data URL:', error);\r\n    return dataURL; // Return original if there was an error\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  installReadbackSpoofing,\r\n  applyNoiseToDataURL\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/browser-entry.js\");\n",""],"names":[],"sourceRoot":""}